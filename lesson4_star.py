# Задача со ЗВЁЗДОЧКОЙ. Решать НЕобязательно.
# Программа получает на вход натуральное число num.
# Программа должна вывести другое натуральное число, удовлетворяющее условиям:
# Новое число должно отличаться от данного ровно одной цифрой
# Новое число должно столько же знаков как исходное
# Новое число должно делиться на 3
# Новое число должно быть максимально возможным из всех таких чисел
# Например (Ввод --> Вывод) :
#
# 379 --> 879
# 15 --> 75
# 4974 --> 7974

def max_division_by_3(num):
    # Здесь нужно написать код
    new_num = 0
    lst = list(map(int, str(num)))  # создаем список
    lst1 = []  # чтобы не испортить основной список
    k = 0  # переменная для проверки, что отличается на 1 знак
    for j in range(0, len(lst)):  # пройтись по индексам списка
        if k == 1:
            break  # оборвать цикл полностью, если уже поменяли 1 цифру
        elif lst[j] == 9:  # если 9 двигаемся на след индекс
            continue
        elif lst[j] < 9:  # если менее 9 подбираем цифру
            for m in range(9, lst[j], -1):  # начинаем с 9 и далее по списку подставлять цифру
                lst1 = lst.copy()
                lst1.pop(j)
                lst1.insert(j, m)
                new_num = int(''.join(map(str, lst1)))  # собрать в число
                if new_num % 3 == 0:  # если на 3 делится без остатка
                    k = 1  # записать, что изменилась одна цифра, чтобы больше не заходить
                    break
                else:
                    continue
    return new_num

# Ниже НИЧЕГО НЕ НАДО ИЗМЕНЯТЬ


data = [
    379, 810, 981, 4974, 996, 9000, 15, 0, 9881, 9984, 9876543210, 98795432109879543210
]

test_data = [
    879, 870, 987, 7974, 999, 9900, 75, 9, 9981, 9987, 9879543210, 98798432109879543210
]


for i, d in enumerate(data):
    assert max_division_by_3(d) == test_data[i], f'С набором {d} есть ошибка, не проходит проверку'
    print(f'Тестовый набор {d} прошёл проверку')
print('Всё ок')
